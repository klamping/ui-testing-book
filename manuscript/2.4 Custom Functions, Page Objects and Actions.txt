# 2.4 Custom Functions, Page Objects & Actions

## 2.4.1 You've Got Me Hooked

If you recall from the previous chapter, at the beginning we had set out to write three tests. They were: 

```js
// Login Page:
// should let you log in
// should error with a missing username
// should error with a missing password
```

We completed the first, but haven't touched the other two. Let's get to that now.

Both tests are very similar. In fact, they're almost like the first test we wrote, except will be omitting certain steps and validating the page didn't change.

Use the "test comments" practice we used in our first test, here's what our two tests will do:

```js
// - go to the login page
// - enter either a valid username or a valid password into the corresponding input
// - click the 'Sign In' button
// - assert that correct error message is shown and we aren't logged in
```

If your memory serves you well, a couple of those steps are the same as what we've already coded. And if you're lazy like me, you don't want to code anymore than you already have to.

Well, let's avoid that extra work by moving our 'go to login page' step to a common location.

MochaJS provides a feature called "hooks", that allow you to run custom test code around your tests. Each `describe` block can have any or all of the following hooks implemented:

- before
- beforeEach
- afterEach
- after

`before` and `after` are run before/after the test suite. So if you have five tests, `before` would run before the set of tests, and `after` after the tests.

`beforeEach` and `afterEach` however, execute around each test. Here's how the execution flow runs for a set of tests:

- before
- beforeEach
- test 1
- afterEach
- beforeEach
- test2
- afterEach
- after

As you can see, `beforeEach` and `afterEach` run multiple times based on the number of tests written. `before` and `after` only run at the start/end of the test suite.

Okay, enough explanation, let's see this in action. In our first test, we load the login page by running `browser.url('./login');`. This is the code we're going to want to move to our hook.

Should we use a `before` or `beforeEach` hook though? That's a good question to ask, because there are benefits/drawbacks to each. The benefit to using a `beforeEach` hook is that we can be sure our page is "fresh" for our test. Changes made in a previous test won't impact this one (mostly... sometimes this isn't true). 

On the other hand, because `beforeEach` runs for every test, every step you take in it requires one more command to be run, extending the test execution time.

For us, the decision here is pretty easy. We're going to go with a `beforeEach` hook because we definitely need a fresh page for each of our tests (we don't want an error from our `missing username` test to contaminate our `missing password` test.

With that, let's move our step over. This is what the code looks like:

```js
const expect = require('chai').expect;

describe('Login Page', function () {
    beforeEach(function () {
        browser.url('./login');
    });
    
    it('should let you log in', function () {
        $('input[type="email"]').setValue('demowdio@example.com');
        $('input[type="password"]').setValue('wdiodemo');

        const $signIn = $('button*=Sign in');
        $signIn.click();

        $signIn.waitForExist(undefined, true);

        // Get the URL of the page, which should no longer include 'login'
        expect(browser.getUrl()).to.not.include('/login');
    });
});
```

Not much has changed, but we've set ourselves up to do a little less work in the long run.

## 2.4.2 Getting the Error Text

As mentioned, there isn't much different between these two new tests we're writing and our previous test. That means I won't be covering what we've already talked about. So, on that note, here's what our two new test are almost going to look like:

```js
const expect = require('chai').expect;

describe('Login Page', function () {
    beforeEach(function () {
        browser.url('./login');
    });
    
    it('should let you log in', function () {
        $('input[type="email"]').setValue('demowdio@example.com');
        $('input[type="password"]').setValue('wdiodemo');

        const $signIn = $('button*=Sign in');
        $signIn.click();

        $signIn.waitForExist(undefined, true);

        // Get the URL of the page, which should no longer include 'login'
        expect(browser.getUrl()).to.not.include('/login');
    });

    it('should error with a missing username', function () {
        $('input[type="password"]').setValue('wdiodemo');

        $('button*=Sign in').click();

        // assert that error message is showing
    });

    it('should error with a missing password', function () {
        $('input[type="email"]').setValue('demowdio@example.com');

        $('button*=Sign in').click();
        
        // assert that error message is showing
    });
});
```

As you can see, the only work left to do is assert that the error message is showing. How do we go about this?

The first thing we need to know is what the HTML of the error message looks like. Here's an example with the email field empty:

```html
<ul class="error-messages">
  <li>email can't be blank</li>
</ul>
```

Given that HTML, we can come up with a couple of different selectors:

- Use a 'text based selector' to check for the specific error message (e.g. `$("li*=email can't be blank")`)
- Use a class based selector (e.g. `$('.error-messages li')`), then validate using a special `getText` to assert the message is correct.

Using the first method, we'd combine our test-based selector with a `waitForExist` that runs after our test actions are executed. We wouldn't have an assertion, as the timeout that would occur if that selector weren't found would act as the check. Here's what the code would look like:

```js
it('should error with a missing username', function () {
    $('input[type="password"]').setValue('wdiodemo');

    $('button*=Sign in').click();

    $("li*=email can't be blank").waitForExist();
});
```

As mentioned before, there is no `expect` using this method. In theory, you could use the `isExisting` method to validate that element exists, but it would be completely unnecessary. The reason is that, if the element doesn't exist, `waitForExist` will throw a timeout error, preventing the assertion from ever running. If `waitForExist` doesn't fail (the element exists), then we already know at that point that our assertion will pass, making it redundant.

One drawback to this approach is that the test doesn't fail immediately. If the error message shows, but is incorrect, it will still take the full timeout period to fail. 

Alternatively, using the second approach, we can get the text as soon as it appears on the page, and fail it immediately if needed. But to do this, we need to use a new command called `getText`. 

As you can probably guess, `getText` gets the visible text of an element. Notice that I mentioned "visible". If the element is hidden, the `getText` command will return an empty string. A great example of this is an item in a dropdown menu. Since that item isn't visible until you open up the dropdown menu, `getText` will return an empty string. If you were to open up the dropdown menu, then run `getText`, it would successfully return the text value.

There is a workaround to this issue: The `getHTML` command. Just like `getText`, `getHTML` returns the HTML value of an element, including the text inside it. Let's look again at the HTML for our error message:

```html
<ul class="error-messages">
  <li>email can't be blank</li>
</ul>
```

Assuming that all elements are visible, here's what our `getText` and `getHTML` commands would return:

```js
$('.error-messages li').getText(); // returns "email can't be blank"
$('.error-messages li').getHTML(); // returns "<li>email can't be blank</li>"
$('.error-messages').getText(); // returns "email can't be blank"
$('.error-messages').getHTML(); // returns "<ul class="error-messages"><li>email can't be blank</li></ul>"
```

First, notice how getting the text of the parent element returned the same value as getting the text of the individual element itself. That's by design, and you can use that knowledge to your advantage, so keep it in mind.

Second, the `getHTML` included the `<li>` tags in the response. It would be a more valid test if we ignored the HTML of the page and only returned the text content. We can do that! `getText` accepts a single paramenter, which is a boolean flag to include the selector element tag or not. By default it's `true`, and therefore includes that tag. If we pass in false, we get different results:

```js
$('.error-messages li').getHTML(false); // returns "email can't be blank"
$('.error-messages').getHTML(false); // returns "<li>email can't be blank</li>"
```

In the first command, now we get just the text with no HTML. However, because that boolean flag only works on the main element, any child tags will still be included in the results, regardless of what we pass in. This means that `getHTML` still has its limitations, but I still like keeping the command in my back pocket for times when I need to get the text of a hidden element. 

Since our error message shouldn't be hidden, let's go with the `getText` command in our test. To update our test, we need to add two steps:

1. Wait for the form to validate and display the error message(s) on the page
2. Get the text of the error messages and assert that they're correct

If you inspect the HTML on page load, you'll notice that the `<ul class="error-messages">` tag is already on the page, just empty. This means that we can't use `$('.error-messages').waitForExist()`, as it's already there.

Instead, we can do two alternatives:

- Wait for that element to be displayed: `$('.error-messages').waitForDisplayed()`
- Wait for a child `li` to exist: `$('.error-messages li').waitForExist()`

They're pretty much equal in terms of effectiveness, but I think I'll go with the second option as `waitForDisplayed` isn't fully supported by all browsers.

After waiting for the `li` to exist, we can get the text of it via `getText` like shown in the previous examples. We'll include those results in our assertion, completing our test:

```js
it('should error with a missing username', function () {
    $('input[type="password"]').setValue('wdiodemo');

    $('button*=Sign in').click();

    $('.error-messages li').waitForExist();

    const message = $('.error-messages li').getText();

    // assert that error message is showing
    expect(message).to.equal(`email can't be blank`);
});
```

Great, we now have a fully-built test ready for running. One quick tip before doing that: Mocha comes with two special abilities that make it easier to develop with. 

## 2.4.3 Only One More Thing I Don't Want to Skip

Say we're working on a test, but it's failing and we don't really have time to fix it right now. Instead of deleting or commenting out the entire test, you can add `.skip` to either the `describe` or `it` function call, and it will skip the test. Here are some examples:

```js
describe('All tests', function () {
    it('will run', function () {})

    it.skip('will be skipped', function () {})

    describe.skip('Skipped Suite', function () {
        it('will be skipped', function () {})
        it('will also be skipped', function () {})
    })
});
```

Alternatively, say you only want to run a single test (or single set of tests). You can append `.only` to the `it` or `describe` function call to have only that test (and any other tests with `only` marked) run:

```js
describe('All tests', function () {
    it('will be skipped', function () {})

    it.only('will run', function () {})

    describe.only('Only Suite', function () {
        it('will run', function () {})
        it('will also run', function () {})
    })
});
```

Notice how we can have multiple `only` tests and all of them marked as so will run? That's as intended, and you can use it to run only a few tests, instead of having to go in and run each test individually, moving the `.only` between them.

Okay, so we can use this new knowledge to run just the single new test that we've written. Here's what our updated file will look like:

```js
const expect = require('chai').expect;

describe('Login Page', function () {
    beforeEach(function () {
        browser.url('./login');
    });

    it('should let you log in', function () {
        $('input[type="email"]').setValue('demowdio@example.com');
        $('input[type="password"]').setValue('wdiodemo');

        const $signIn = $('button*=Sign in');
        $signIn.click();

        $signIn.waitForExist(undefined, true);

        // Get the URL of the page, which should no longer include 'login'
        expect(browser.getUrl()).to.not.include('/login');
    });

    it.only('should error with a missing username', function () {
        $('input[type="password"]').setValue('wdiodemo');

        $('button*=Sign in').click();

        $('.error-messages li').waitForExist();

        const message = $('.error-messages li').getText();

        // assert that error message is showing
        expect(message).to.equal(`email can't be blank`);
    });

    it('should error with a missing password', function () {
        $('input[type="email"]').setValue('demowdio@example.com');

        $('button*=Sign in').click();

        // assert that error message is showing
    });
});
```

After running our `npx wdio --spec=login.js` command from the terminal again, you should see the green checkmark next to your passing test. It's always a good idea to make sure your assertion actually works, so try changing the expected text or commenting our the `click` command to validate the test fails if that error message doesn't show. 

Before we copy/paste our missing password test, there's one more improvement we can make to the one we just wrote. Notice how we use the `$('.error-messages li')` selector twice? We can actually store a reference to that element in our code so we only have to include it once. Here's what I mean:

```js
const $message = $('.error-messages li');
$message.waitForExist();
const message = $message.getText();
```

We store the reference to the element as a constant, then use that refence in the next two steps. We've actually already done this before with the `signIn` button, but I wanted to go over it again as it's an important technique to be aware of. By using it, we only have to define our selector once, making updates as that selector changes much easier (this will be a common theme as we get into Page Objects).

Also note the `$` prefix of our variable name. That's not required in any way, but I find it helpful to differentiate between WebdriverIO element references and other variables that might be stored. If you look at `$message` and `message`, it's not a stretch to guess that `$message` is the WebdriverIO element, and `message` is the text of that element.

Since the missing password test is so similar to the missing email test, I'm going to skip over it and just post the full code here:

```js
const expect = require('chai').expect;

describe('Login Page', function () {
    beforeEach(function () {
        browser.url('./login');
    });

    it('should let you log in', function () {
        $('input[type="email"]').setValue('demowdio@example.com');
        $('input[type="password"]').setValue('wdiodemo');

        const $signIn = $('button*=Sign in');
        $signIn.click();

        $signIn.waitForExist(undefined, true);

        // Get the URL of the page, which should no longer include 'login'
        expect(browser.getUrl()).to.not.include('/login');
    });

    it('should error with a missing username', function () {
        $('input[type="password"]').setValue('wdiodemo');

        $('button*=Sign in').click();

        const $message = $('.error-messages li');
        $message.waitForExist();

        const message = $message.getText();

        // assert that error message is showing
        expect(message).to.equal(`email can't be blank`);
    });

    it('should error with a missing password', function () {
        $('input[type="email"]').setValue('demowdio@example.com');

        $('button*=Sign in').click();

        const $message = $('.error-messages li');
        $message.waitForExist();

        const message = $message.getText();

        // assert that error message is showing
        expect(message).to.equal(`password can't be blank`);
    });
});
```

## 2.4.4 Custom Test Functions

While we did some work to reduce repetition in our code so far by using the `beforeEach` hook, there's still more we can do. If you look at the first couple steps in all three tests, we do two things:

1. Fill out the form fields
2. Click the "Sign In" button

Shouldn't we move these to the `beforeEach` function? No, because the specifics in each individual test vary just enough for them to not fit a common `beforeEach` function.

Rather, we're going to create a custom function that will handle the unique parts of our login steps in a common way. This function will take an email and password value, then click the sign in button. We'll call this function from inside our tests. 

Here's what the function is going to look like:

```js
function login(email, password) {
    $('input[type="email"]').setValue(email);
    $('input[type="password"]').setValue(password);

    const $signIn = $('button*=Sign in');
    $signIn.click();
}
```

We're using the exact code in our first test, so let's look at how that will look replaced:

```js
it('should let you log in', function () {
    login('demowdio@example.com', 'wdiodemo');

    $('button*=Sign in').waitForExist(null, true);

    // Get the URL of the page, which should no longer include 'login'
    expect(browser.getUrl()).to.not.include('/login');
});
```

In place of those commands, we call the `login` function, passing in our username and password values. This simplifies our test a bit, while keeping all the same functionality. 

So what do we do for the other tests where we don't have a value for one of our fields? Well, we just pass in an empty string:

```js
it('should error with a missing username', function () {
    login('', 'wdiodemo');

    const errorMessages = $('.error-messages li');
    errorMessages.waitForExist();

    expect(errorMessages.getText()).to.equal(`email can't be blank`);
});
```

WebdriverIO will take that empty string and set the value of the corresponding field to it. It's technically an extra command being run, but it helps reduce repetition in our codebase so I find it worth it.

Alltogether, here's what the updates look like:

```js
const expect = require('chai').expect;

function login(email, password) {
    $('input[type="email"]').setValue(email);
    $('input[type="password"]').setValue(password);

    const $signIn = $('button*=Sign in');
    $signIn.click();
}

describe('Login Form', function () {
    beforeEach(function () {
        browser.url('./login');
    })

    it('should let you log in', function () {
        login('demowdio@example.com', 'wdiodemo');

        $('button*=Sign in').waitForExist(null, true);

        // Get the URL of the page, which should no longer include 'login'
        expect(browser.getUrl()).to.not.include('/login');
    });

    it('should error with a missing username', function () {
        login('', 'wdiodemo');

        const errorMessages = $('.error-messages li');
        errorMessages.waitForExist();

        expect(errorMessages.getText()).to.equal(`email can't be blank`);
    });

    it('should error with a missing password', function () {
        login('demowdio@example.com', '');

        const errorMessages = $('.error-messages li');
        errorMessages.waitForExist();

        expect(errorMessages.getText()).to.equal(`password can't be blank`);
    });
});
```

So with this custom function, we've moved browser commands into a common area, reducing the redudancy of our code, which is good. That said, it's also made the codebase more complex. Instead of being able to find everything you need for a test within it, we now have to track down this `login` function and figure out what it does. 

As with all things programming, this is a tradeoff we make. Every step to reduce the verbosity of our tests increases the complexity of it. Be mindful of this as we move into the next section... perhaps, for the sake of simplicity in a basic test suite, the following knowledge may be overdoing it in some circumstances. 

## 2.4.5 Basics of Page Objects

The function we built was pretty neat, and opens up the idea of moving implementation specifics outside of the tests and into common areas more available for re-use. Page Objects build on that idea by providing a nomenclature for defining a page and the actions you can take on it. 

We defined a "login", function, but what if we could define the "login" page itself. The specific elements on that page, and the various actions you could take upon it. That's wher Page Objects slide in. 

Despite the "login" function reducing some code duplication, we still had to restate the `Sign in` button selector in our first test. Wouldn't it be nice if we could create a common area to store all of our element selectors? 

Well, a basic system would be to define each selector as a constant, then reference that constant in our tests:

```js
const emailSelector = 'input[type="email"]';
const passwordSelector = 'input[type="password"]';
const signInSelector = 'button*=Sign in';

function login(email, password) {
    $(emailSelector).setValue(email);
    $(passwordSelector).setValue(password);

    const $signIn = $(signInSelector);
    $signIn.click();
}
```

This is an improvement, but is only okay as far as code style goes. We still have to call the `$()` function a bunch, which makes the code a little bit more clunky. How about we switch those selectors to be element references?

```js
const $email = $('input[type="email"]');
const $password = $('input[type="password"]');
const $signIn = $('button*=Sign in');

function login(email, password) {
    $email.setValue(email);
    $password.setValue(password);

    $signIn.click();
}
```

Isn't that a bit better? No! It's much worse! If you tried running that code, you'd get several failures.

The reason is that we're trying to run the `$` function outside of it's normal living space (this has to do with the `wdio-sync` library, but I won't go into those details). Because the constants are defined outside of the WebdriverIO context (which only exists within the specific Mocha functions), it errors out with a message of `$email.setValue is not a function`.

So what we really need is "just in time" references. We want to store the code to run to get the reference to the element, but only run that code when we're inside our tests. What if we write some cute little functions that do that?

```js
const $email = function () {
  return $('input[type="email"]');
}
const $password = function () {
  return $('input[type="password"]');
}
const $signIn = function () {
  return $('button*=Sign in');
}

function login(email, password) {
    $email().setValue(email);
    $password().setValue(password);

    $signIn().click();
}
```

Okay, so that code works, but geez is it ugly. Having to call our element references as a function everytime we want to access them? Certainly there's a cleaner way of achieving the same effect...

Surprise, there is! Okay... maybe not surprise. I kind of worked too hard to set myself up for all of this.

Regardless, newer versions of JavaScript let us achieve this with a much cleaner syntax. Using the `class` syntax (introduced in ECMAScript 2015 for those keeping track), we can define `get` functions that look like standard variables, but act like functions. 

First, we need to define a new `class` to hold all of our authentication related information:

```js
class Auth {
}
```

Then, we define our `get` functions inside of it:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }
}
```

The `get` functions mirror our earlier element reference functions, so it should look familiar. But we don't access them by calling `Auth.$email()`. There is an extra step we need to take to make it all work.

When you define a `class`, you're stating how something "should" work. It's not the same as defining a variable or constant, which are able to be reference right away. No, with a class, you first have to "instantiate" it. Instantiate is a big fancy term meaning "the creation of a real instance or particular realization of an abstraction or template such as a class." Not only that, but the more you say "instantiate", the smarter you sound.

So we need to "instantiate" our class before we can use it. That's pretty easy:

```js
const auth = new Auth();
```

So we call `new` on our Auth class, calling it like a function, and storing it as a `auth` constant. Now we have a real reference that we can use in our test. 

Collectively, this is how our code now looks using classes:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }
}

const auth = new Auth();

function login(email, password) {
    auth.$email.setValue(email);
    auth.$password.setValue(password);

    auth.$signIn.click();
}
```

We got rid of the function call for each of our element references, and prepended everything with our `auth` instantiated class. If you're counting text characters, we've actually gone up, but to me it feels a lot cleaner and more self-documenting. All the elements related to authentication are stored inside of the authentication instance. 

One added benefit of this approach is that we can use this `auth` instance throughout our tests. Here's what the fully updated test suite looks like:

```js
const expect = require('chai').expect;

class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }
}

const auth = new Auth();

function login(email, password) {
    auth.$email.setValue(email);
    auth.$password.setValue(password);

    auth.$signIn.click();
}

describe('Login Form', function () {
    beforeEach(function () {
        browser.url('./login');
    })

    it('should let you log in', function () {
        login('demowdio@example.com', 'wdiodemo');

        auth.$signIn.waitForExist(null, true);

        // Get the URL of the page, which should no longer include 'login'
        expect(browser.getUrl()).to.not.include('/login');
    });

    it('should error with a missing username', function () {
        login('', 'wdiodemo');

        auth.$errorMessages.waitForExist();

        expect(auth.$errorMessages.getText()).to.equal(`email can't be blank`);
    });

    it('should error with a missing password', function () {
        login('demowdio@example.com', '');

        auth.$errorMessages.waitForExist();

        expect(auth.$errorMessages.getText()).to.equal(`password can't be blank`);
    });
});
```

Notice how the test no longer stores selector information. All of those details are inside of our page object. This [seperation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns) helps reduce maintanence efforts (less places to change things) and improves readability. Instead of our test code being cluttered with selectors, they have more understandable variable names.

## 2.4.6 Naming Patterns

Speaking of, how should you name your variables? Overall, that's a individual/team choice, but there are a few things you'll want to consider.

One option is to include the element type in the variable name (e.g. `$emailInput`, `$passwordInput`). While it's nice to know we're working with an input element, there are couple drawbacks of this approach:

1. It's more verbose. You can remidiate this by using shorter names: `inp` vs `input` or `lbl` instead of `label`. But then that can be confusing to folks unfamiliar with the nomenclature. 
2. Not all elements line up nicely with an element name. For example, container elements. Are you going to name it `accordionContainer` or `accordionDiv`? Are you going to name a list as `todoList` or `todoUl`?

I'm not saying including element information is a bad idea, only that you need to map out how you plan on being consistent with your naming pattern.

Another consideration is how you'll name types of components. For example, if you're testing a to-do list, you might have the following HTML:

```html
<ul>
  <li>Item 1</li>
  <li>Item 2</li>
</ul>
```

Here's what the page object may look like:

```js
class TodoList {
    get $container () { return $('ul'); }
    get $$items () { return $$('li'); }
}
```

But it could also be:

```js
class TodoGroup {
    get $parent () { return $('ul'); }
    get $$tasks () { return $$('li'); }
}
```

Either are valid and work well, but the naming scheme is definitely different between the two. Inconsisten naming patterns can cause confusion for newcomers to the codebase, so work on being clear with the pattern you want to define from the start.

## 2.4.7 Page Actions

We were able to move our selectors out of our tests and into our page object; can we do they same with the login function? It's technically part of our "Auth" flow, and it would be great to group it inside of our Auth page object for reuse across our tests.

Yes, we certainly can move it, and that's just what we're going to do next. 

JavaScript classes, which is what we've been using so far to define our page object, allow you to define functions on them (as well as the 'getters' we've already used for our element references). You add these functions in a pretty similar format as normal functions live in the wild.

Instead of declaring your function on its own, you include inside the curly braces that define our class. Let's update our class to declare a "login" function:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }
    
    login (email, password) {
      // take login actions here
    }
}

const auth = new Auth();
```

I didn't include the steps in the function yet, as there's a slight tweak we need to make to the login code. Recall how the login function referenced the `auth` instance we created (e.g. `auth.$signIn.click()`)? If we try a straight copy/paste of that, the code will run successfully, but a bug will be lurking beneath the surface. 

We our function commands reference `auth`, their talking about the specific `auth` instance that's later created in our code. Our page object has no real control over what this instance is named, so any changes to that name will break the code.

For instance, if the instantiation is changed to `const authentication = new Auth();`, our login function will error out with `auth is not defined`, as `auth` no longer exists. This means our function is brittle and liable to break with outside code changes. It's a bad situation to put yourself in.

How do we work around this issue? Well, conveniently, JavaScript classes give us a pre-defined `this` keyword that we can use to reference whatever instance of our class is. We don't need to declare it anywhere, it exists as part of the normal runtime (similar to how we don't define `browser`, it already exists when we run our code).

JavaScript `this` can be a bit confusing, and we'll get in to scenarios in the future where that's true. In our code right now though, just imagine that `this` is a reference to the overall class. Let's add the commands into our function, replacing `auth` with `this` as necessary:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }

    login (email, password) {
        this.$email.setValue(email);
        this.$password.setValue(password);

        this.$signIn.click();
    }
}
```

Now the `const auth = new Auth();` instantiation can be named anything and our code will still work. By using the magic of `this`, we alleviate the need to know what our instance will be named.

There's one last item to complete in our transition to page actions: we need to update our `login` reference in our test code. Since we want to call the `login` function that belongs to our `auth` instance, we can refer to it in the same way we've accessed our element reference: by prepending the instance name (i.e. `auth`) to our function name. 

So `login('demowdio@example.com', 'wdiodemo');` becomes `auth.login('demowdio@example.com', 'wdiodemo');`. Now when we run the code, it will look for the `login` function on the `auth` page object instance. Here's what the entire file now looks like:

```js
const expect = require('chai').expect;

class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }

    login (email, password) {
        this.$email.setValue(email);
        this.$password.setValue(password);

        this.$signIn.click();
    }
}

const auth = new Auth();

describe('Login Form', function () {
    beforeEach(function () {
        browser.url('./login');
    })

    it('should let you log in', function () {
        auth.login('demowdio@example.com', 'wdiodemo');

        auth.$signIn.waitForExist(null, true);

        // Get the URL of the page, which should no longer include 'login'
        expect(browser.getUrl()).to.not.include('/login');
    });

    it('should error with a missing username', function () {
        auth.login('', 'wdiodemo');

        auth.$errorMessages.waitForExist();

        expect(auth.$errorMessages.getText()).to.equal(`email can't be blank`);
    });

    it('should error with a missing password', function () {
        auth.login('demowdio@example.com', '');

        auth.$errorMessages.waitForExist();

        expect(auth.$errorMessages.getText()).to.equal(`password can't be blank`);
    });
});
```

Now we've fully built-out our page object with element references and custom functions. This framework will be used throughout our tests moving forward, so be prepared to see a lot of this format. It might feel a bit overcomplicated right now, but it opens up opportunities for extension in the future that we'll be covering in the next chapter. 

## 2.4.8 Improving Our Login Detection

We've almost completely eradicated the code duplication between our tests, but there's one final step we can take to further pare down our code. In each of our tests, we have a `waitForExist` command that pauses execution until the page has updated (e.g. `auth.$signIn.waitForExist(null, true);`). I mentioned the `waitUntil` function a while back; now it's time to take advantage of it. 

The reason we haven't addressed this issue before is that we're waiting on two different conditions:

1. The login button to stop existing: `auth.$signIn.waitForExist(null, true);`
2. An error message to exist: `auth.$errorMessages.waitForExist();`

On the outside, it doesn't make sense to try and combine these, as one is for a successful login and the other is for a failed login. But what if we could say "Wait for either this *or* that"?

This is where a custom `waitUntil` command comes in. It's your universal weapon if you want to wait on some specific scenario. It expects a condition and waits until that condition is fulfilled with a truthy value. 

With it, we can say "Wait for the login button to disappear or for an error message to exist". To use the `waitUntil` method, call it and pass in a function that returns a true or false value, depending on if the condition is met. WebdriverIO will keep waiting/calling that function until it either returns true, or reaches the timeout limit. 

For our login method, we can write our function as follows:

```js
browser.waitUntil(function () {
    const signInExists = auth.$signIn.isExisting();
    const errorExists = auth.$errorMessages.isExisting();

    return !signInExists || errorExists;
});
```

Our return statement will return true on any of the following conditions:

- The 'Sign in' button no longer exists (`!` reverses the value of `signInExists`)
- An error exists

And it will return false until either of those conditions is met (checking every half a second by default). If that condition isn't met by our `waitForTimeout` amount, it will fail saying `waitUntil condition timed out after 10000ms`.

Well, that message isn't very helpful. We know waitUntil failed, but unless you were expecting the failure (which you likely weren't), you're going to have to dig in the code to figure out what condition it was. 

We can help that by passing in a custom error message (similar to how we can pass in custom messages to our assertions). The `waitUntil` function signature looks like: 

```
browser.waitUntil(condition, timeout, timeoutMsg, interval)
```

The `condition` is our function, and the `timeoutMsg` is that custom error message we want to show in case of failure. We can avoid overwriting the `timeout` value by passing in `undefined`, which will make the function use whatever default we already have set. Here's what this looks like:

```js
browser.waitUntil(function () {
    const signInExists = auth.$signIn.isExisting();
    const errorExists = auth.$errorMessages.isExisting();

    return !signInExists || errorExists;
}, null, 'The sign in button is not gone and an error never appeared');
```

Perfect! Now we can remove those `waitForExist` statements in our test code and add our new `waitUntil` function to our `login` function:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }

    login (email, password) {
        this.$email.setValue(email);
        this.$password.setValue(password);

        this.$signIn.click();

        // wait until either the sign in button is gone or an error has appeared
        browser.waitUntil(() => {
            const signInExists = this.$signIn.isExisting();
            const errorExists = this.$errorMessages.isExisting();

            return !signInExists || errorExists;
        }, null, 'The sign in button is not gone and an error never appeared');
    }
}
```

Two important things to point out that I changed here.

1. I updated `auth.` to `this.` (e.g. `auth.$signIn.isExisting()` -> `this.$signIn.isExisting()`). That's inline with the changes we made earlier.
2. I used a `fat arrow` function definition, instead of the previous `function () {}`. That's because our `waitUntil` function will be called with a different `this` value if we don't use it.

Remember how I said `this` can be tricky? Well, here's your example. If we used the following code:

```js
browser.waitUntil(function () {
    const signInExists = this.$signIn.isExisting();
    const errorExists = this.$errorMessages.isExisting();

    return !signInExists || errorExists;
}, null, 'The sign in button is not gone and an error never appeared');
```

The `this` in our code wouldn't refer to our page object, but rather the WebdriverIO `browser` instance (so it would be the same as calling `browser.$signIn.isExisting()`, which doesn't work). By using a fat arrow function, we bind `this` to the page object, allowing us to say `this.$signIn.isExisting();`. 

For more details on fat arrow functions, have a read through this in-depth article: https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/

Here's what our fully updated login.js file looks like:
 
```js
const expect = require('chai').expect;

class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }

    login (email, password) {
        this.$email.setValue(email);
        this.$password.setValue(password);

        this.$signIn.click();

        // wait until either the sign in button is gone or an error has appeared
        browser.waitUntil(() => {
            const signInExists = this.$signIn.isExisting();
            const errorExists = this.$errorMessages.isExisting();

            return !signInExists || errorExists;
        }, null, 'The sign in button is not gone and an error never appeared');
    }
}

const auth = new Auth();

describe('Login Form', function () {
    beforeEach(function () {
        browser.url('./login');
    })

    it('should let you log in', function () {
        auth.login('demowdio@example.com', 'wdiodemo');

        // Get the URL of the page, which should no longer include 'login'
        expect(browser.getUrl()).to.not.include('/login');
    });

    it('should error with a missing username', function () {
        auth.login('', 'wdiodemo');

        expect(auth.$errorMessages.getText()).to.equal(`email can't be blank`);
    });

    it('should error with a missing password', function () {
        auth.login('demowdio@example.com', '');

        expect(auth.$errorMessages.getText()).to.equal(`password can't be blank`);
    });
});
```

## 2.4.9: Separating Files

We've finished with our Page Object/Actions, but there's still one last thing to do. As we move forward with new tests, it will be really helpful to have this Auth page object available elsewhere. It's a very good idea to separate out your page objects from your test files, so let's do that. 

Grab all of your `class` code and move it to a new file that looks like:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }

    login (email, password) {
        this.$email.setValue(email);
        this.$password.setValue(password);

        this.$signIn.click();

        // wait until either the sign in button is gone or an error has appeared
        browser.waitUntil(() => {
            const signInExists = this.$signIn.isExisting();
            const errorExists = this.$errorMessages.isExisting();

            return !signInExists || errorExists;
        }, null, 'The sign in button is not gone and an error never appeared');
    }
}

module.exports = Auth;
```

In addition to the moved code, we added an 'export' for our class via Node's export system at the bottom of the file. We did this by attaching our class to the `module.export` value ([Node.js technical docs on `module.export`](https://nodejs.org/api/modules.html#modules_exports_shortcut)).

Now we need to save our file. First, we need a new folder to save our page object in. If we save it to our specs folder, WebdriverIO will think it's a test spec file and try running it at so. Instead, let's save it outside of the `test/specs` folder, to a specific page objects folder at `test/pageObjects`.

For the filename, I like to use a leading capital letter, signifying that we've exported a single class. I also like to append `.page` in my filename, to let others know that this is a page object definition. So my filename will be saved to `test/pageObjects/Auth.page.js`.

Finally, back in our test file, we need to import our page object for usage:

```js
const expect = require('chai').expect;
const Auth = require('../pageObjects/Auth.page');

const auth = new Auth();
```

With everything moved around and hooked up, you can run your tests one more time to ensure it's all plugged in correctly.

In the next chapter, we're going to to use our new Auth page object to help ourselves get logged in, so we can test all sorts of authenticated functionality. 

## 2.4.10 Chapter Challenge

- Write a set of tests for the register account page that checks the following requirements
  - Can access from the login page
  - Requires username, email, password
  - Checks that password isn't too short (minimum is 8 characters)
  - username has already been taken
  - email has already been taken
  - Takes you to home page once you register
